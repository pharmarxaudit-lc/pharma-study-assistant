# Deployment Lessons Learned

Critical insights and best practices discovered during the Replit deployment of the Pharmacy Study Assistant application.

**Last Updated:** 2025-10-17

---

## Table of Contents

1. [Cost Optimization](#cost-optimization)
2. [Configuration Pitfalls](#configuration-pitfalls)
3. [Deployment Best Practices](#deployment-best-practices)
4. [Machine Sizing](#machine-sizing)
5. [Build Process](#build-process)
6. [Testing & Verification](#testing--verification)

---

## Cost Optimization

### Lesson: Analyze Usage Patterns Before Choosing Deployment Type

**What We Learned:**
- **Autoscale** charges per active hour: Can be expensive for regular daily usage
- **Reserved VM** has fixed monthly cost: Better for predictable usage patterns
- **Static Deployment** only works for frontend-only apps (not full-stack)

**Our Case Study:**
- **Usage Pattern:** 3-4 hours/day on weekdays (~70 hours/month)
- **Autoscale Cost:** 70 hours × $0.461/hour = **$32.27/month**
- **Reserved VM Cost:** **$20/month** (fixed)
- **Savings:** **$12.27/month (38% cheaper)**

**Decision Framework:**

| Usage Pattern | Recommended | Cost Model |
|--------------|-------------|------------|
| < 44 hours/month | Autoscale | Pay per use |
| 44-200 hours/month | Reserved VM | Fixed monthly |
| Irregular bursts | Autoscale | Scales to zero |
| 24/7 production | Reserved VM | Predictable cost |

**Action Items:**
- ✅ Calculate expected monthly active hours
- ✅ Compare Autoscale rate vs Reserved VM cost
- ✅ Consider growth - will usage increase?
- ✅ Check if traffic is predictable or bursty

---

## Configuration Pitfalls

### Lesson 1: Avoid Duplicate Build Commands

**The Problem:**
Original configuration had frontend build in BOTH build command AND run command:

```toml
# ❌ WRONG - Builds frontend TWICE on every deployment
[deployment]
build = ["sh", "-c", "cd frontend && npm install && npm run build"]
run = ["sh", "-c", "cd frontend && npm run build && cd .. && python backend/app.py"]
```

**Impact:**
- Wastes deployment time (builds twice)
- Wastes compute resources
- Slows down deployment process
- No functional benefit

**The Fix:**

```toml
# ✅ CORRECT - Build once, run backend only
[deployment]
build = ["sh", "-c", "cd frontend && npm install && npm run build"]
run = ["sh", "-c", "python backend/app.py"]
```

**Why This Works:**
- **Build phase:** Installs dependencies and builds frontend (happens once)
- **Run phase:** Only starts the Python backend server (serves pre-built frontend)
- Frontend files are already in `frontend/dist/` from build phase

**Key Takeaway:** Separate build-time operations from runtime operations. Build commands should prepare assets; run commands should start services.

---

### Lesson 2: Machine Specs Must Match Workload

**The Problem:**
Initial configuration used oversized machine (4 vCPUs / 8 GiB RAM) for a light workload.

**Analysis:**
```
Application Requirements:
- Flask backend: Lightweight Python server
- SQLite database: Embedded (no separate DB server)
- 325 pre-generated questions: Low memory footprint
- Expected concurrent users: 1-5 max
- API calls: Claude API (external, not CPU-intensive locally)

Memory Usage:
- Python + Flask: ~100-200 MB
- SQLite: ~50 MB
- Frontend static files: ~5 MB
- Uploads/temp files: ~50 MB
Total: ~300 MB actual usage

CPU Usage:
- Most time waiting for Claude API responses
- Minimal CPU for serving static files
- SQLite queries are fast and simple
```

**Sizing Decision:**

| Machine Size | Use Case | Our Fit |
|-------------|----------|---------|
| 0.5 vCPU / 1 GiB RAM | Too small | ❌ Too little RAM |
| **0.5 vCPU / 2 GiB RAM** | Light apps | ✅ **Perfect fit** |
| 1 vCPU / 2 GiB RAM | Moderate load | ⚠️ Overkill |
| 4 vCPU / 8 GiB RAM | Heavy compute | ❌ Massive overkill |

**Key Factors:**
- **RAM:** Need minimum 2 GiB for Python + SQLite + buffers
- **CPU:** 0.5 vCPU sufficient (most time waiting on external API)
- **Concurrency:** Low (single user during study sessions)

**Validation Approach:**
1. Start with smallest viable size (0.5 vCPU / 2 GiB RAM)
2. Monitor performance during real usage
3. Scale up ONLY if experiencing issues
4. Better to start small and grow than overpay from day 1

**Cost Impact:**
- 4 vCPU / 8 GiB: ~$1.014/hour × 44 hours = $44.62/month
- 0.5 vCPU / 2 GiB: $20/month (Reserved VM)
- **Savings: $24.62/month (55% reduction)**

---

### Lesson 3: Verify Secrets Before Deployment

**Critical Requirement:**
Application CANNOT function without `ANTHROPIC_API_KEY` - it's not optional.

**Verification Checklist:**
```bash
# Before clicking "Publish", verify:
✅ ANTHROPIC_API_KEY exists in Replit Secrets
✅ Key format is correct (starts with sk-ant-)
✅ Key has API credits available
✅ SESSION_SECRET generated (or auto-generated by Flask)
```

**Common Mistakes:**
- ❌ Forgetting to add secret before deployment
- ❌ Using test/invalid API key
- ❌ Hardcoding keys in code (security risk!)
- ❌ Not checking if key has credits

**Best Practice:**
1. Add secrets FIRST (before any deployment attempt)
2. Test locally with same secrets
3. Use Replit's Secrets panel (not .env files)
4. Never commit keys to git

---

## Deployment Best Practices

### Lesson 4: Review ALL Settings Before Publishing

**The Checklist:**

1. **Machine Configuration**
   - [ ] Deployment type chosen (Reserved VM vs Autoscale)
   - [ ] Machine size appropriate for workload
   - [ ] Cost reviewed and approved

2. **Build Configuration**
   - [ ] Build command builds frontend only
   - [ ] Run command starts backend only
   - [ ] No duplicate operations

3. **Secrets & Environment**
   - [ ] All required secrets configured
   - [ ] API keys valid and funded
   - [ ] Environment variables set

4. **Access & Networking**
   - [ ] Deployment visibility set (Public/Private)
   - [ ] URL noted for testing
   - [ ] Port configuration correct

**Why This Matters:**
- Deployment takes 4-5 minutes (Provision → Build → Bundle → Promote)
- Mistakes require full redeployment
- Each deployment consumes resources and time
- Better to spend 2 minutes reviewing than 10 minutes redeploying

---

### Lesson 5: Monitor Deployment Phases

**Deployment Pipeline:**
```
1. Provision  → Allocating resources     (1-2 min)
2. Build      → Running build commands   (1-2 min)
3. Bundle     → Packaging application    (30 sec)
4. Promote    → Making deployment live   (1-2 min)
Total: ~4-5 minutes
```

**What to Watch:**
- **Provision:** Should complete quickly (green checkmark)
- **Build:** Watch for errors in frontend build
- **Bundle:** Usually fast, rarely fails
- **Promote:** Longest phase, finalizing deployment

**Red Flags:**
- ⚠️ Build phase stuck > 5 minutes: Likely dependency issue
- ⚠️ Promote phase stuck > 5 minutes: Possible resource constraint
- ❌ Any phase fails: Check logs immediately

**Log Access:**
- During deployment: "Overview" tab shows phases
- After deployment: "Logs" tab shows runtime logs
- No logs available until Promote completes

---

## Machine Sizing

### Lesson 6: Understand RAM vs CPU Requirements

**RAM Requirements (Critical):**
- **Python/Flask:** ~100-200 MB base
- **Dependencies:** ~50-100 MB
- **SQLite:** ~50 MB
- **Working memory:** ~200-500 MB
- **Buffer/headroom:** ~500 MB
- **Minimum:** 1 GiB (tight, may OOM)
- **Recommended:** 2 GiB (comfortable)

**CPU Requirements (Flexible):**
- Most operations: I/O bound (waiting on Claude API)
- Actual CPU usage: < 10% most of the time
- 0.5 vCPU sufficient for single-user app
- Scale CPU for concurrent users, not API calls

**The Trade-off:**
```
RAM is hard limit: OOM = crash
CPU is soft limit: Slow = still works
```

**Recommendation:** Prioritize RAM over CPU for this type of application.

---

## Build Process

### Lesson 7: Frontend Build Must Complete Before Backend Starts

**Why:**
Flask serves static files from `frontend/dist/`. If dist doesn't exist or is incomplete, users get 404 errors.

**Correct Build Order:**
```bash
1. cd frontend
2. npm install          # Install dependencies
3. npm run build        # Build to dist/
4. cd ..
5. python backend/app.py # Start server (serves from dist/)
```

**Replit Configuration:**
```toml
[deployment]
build = ["sh", "-c", "cd frontend && npm install && npm run build"]
run = ["sh", "-c", "python backend/app.py"]
```

**Verification:**
```bash
# After build, verify:
ls -la frontend/dist/index.html  # Should exist
ls -la frontend/dist/assets/     # Should contain JS/CSS bundles
```

---

## Testing & Verification

### Lesson 8: Test in Clean Browser Session

**Why:**
- Browser cache can mask issues
- Cookies/local storage may affect behavior
- Old service workers can serve stale content

**Testing Protocol:**
1. Open deployment in **incognito/private window**
2. Test all major features:
   - [ ] Navigation loads
   - [ ] Exam Prep page shows questions
   - [ ] Process PDFs page accessible
   - [ ] History/Progress pages work
3. Check browser console for errors
4. Verify API calls succeed (Network tab)

**Common Issues Found During Testing:**
- 404 on static assets: Build incomplete
- CORS errors: Flask CORS not configured
- API errors: Missing ANTHROPIC_API_KEY
- Blank pages: Frontend build failed

---

## Key Metrics

### Deployment Success Metrics

**Time to Deploy:**
- Initial setup: ~10 minutes (config + secrets)
- Build + deploy: ~4-5 minutes
- Total first deployment: ~15 minutes

**Cost Optimization Achieved:**
- Original estimate: $44.62/month (oversized machine)
- Final cost: $20/month (right-sized Reserved VM)
- **Savings: 55% reduction**

**Configuration Efficiency:**
- Build commands optimized (removed duplication)
- Deployment time reduced by ~2 minutes
- Resource usage minimized

---

## Quick Wins Summary

1. ✅ **Calculate actual usage** before choosing deployment type
2. ✅ **Right-size your machine** - don't overpay for unused resources
3. ✅ **Separate build from run** - avoid duplicate operations
4. ✅ **Verify secrets first** - save time on failed deployments
5. ✅ **Test in clean browser** - catch caching issues early
6. ✅ **Prioritize RAM over CPU** for I/O-bound apps
7. ✅ **Monitor deployment phases** - catch issues early
8. ✅ **Document your decisions** - help future deployments

---

## Cost Comparison Matrix

| Deployment Type | Machine Size | Monthly Cost | Best For |
|----------------|--------------|--------------|----------|
| Autoscale | 0.5 vCPU / 2 GiB | $0.461/hour | < 44 hrs/month |
| Reserved VM | 0.5 vCPU / 2 GiB | $20/month | 44-200 hrs/month |
| Autoscale | 1 vCPU / 4 GiB | $0.650/hour | Bursty traffic |
| Reserved VM | 1 vCPU / 4 GiB | $28/month | Moderate load 24/7 |

**Break-even Analysis:**
```
Reserved VM ($20) = Autoscale ($0.461/hr) at ~43.4 hours/month
Use Reserved VM if you expect > 44 hours/month active time
```

---

## Future Considerations

### Scaling Indicators

**When to Scale UP:**
- Response times > 2 seconds consistently
- CPU usage > 70% sustained
- Memory usage > 80% regularly
- User complaints about performance

**When to Scale DOWN:**
- CPU usage < 10% always
- Memory usage < 30% always
- No performance issues
- Cost is concern

**Monitoring Approach:**
1. Start with smallest viable configuration
2. Monitor for 1-2 weeks during real usage
3. Adjust based on actual metrics, not guesses
4. Document what drove the change

---

## Conclusion

**Three Most Important Lessons:**

1. **Analyze before deploying** - Understand your usage pattern and workload requirements BEFORE choosing configuration. 5 minutes of analysis saved $24.62/month (55% cost reduction).

2. **Optimize build process** - Separate build-time from runtime operations. Removing duplicate build command saved ~2 minutes per deployment and reduced resource waste.

3. **Verify critical requirements** - Check API keys, secrets, and dependencies BEFORE clicking publish. Pre-deployment verification prevents failed deployments and wasted time.

**ROI of Planning:**
- Time spent planning: ~30 minutes
- Monthly cost savings: $24.62
- Time saved per deployment: ~2 minutes
- Prevented failed deployments: 2+ attempts

**The planning paid for itself in the first month.**

---

**Generated:** 2025-10-17
**Deployment:** https://pharmastudy.replit.app
**Configuration:** Reserved VM, 0.5 vCPU / 2 GiB RAM, $20/month
